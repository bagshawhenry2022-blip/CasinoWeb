<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Stable AI Casino - Hourly 20/50 Dashboard</title>

<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

<style>
  :root{
    --bg:#050404;
    --panel:#0b0a0a;
    --red:#e21b1b;
    --red-2:#ff4d4d;
    --muted:#9b9b9b;
    --glass: rgba(255,255,255,0.02);
    --card-radius:10px;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;background:linear-gradient(180deg,#020202 0%, #080606 100%);color:#eaeaea;-webkit-font-smoothing:antialiased;}
  header{display:flex;align-items:center;justify-content:space-between;padding:12px 18px;border-bottom:1px solid rgba(255,255,255,0.03);background:linear-gradient(90deg, rgba(0,0,0,0.6), rgba(10,5,5,0.2));position:sticky;top:0;z-index:20}
  .title{display:flex;gap:12px;align-items:center}
  .logo{width:40px;height:40px;border-radius:8px;background:linear-gradient(135deg,var(--red),#8b0000);display:flex;align-items:center;justify-content:center;font-weight:700;color:#fff;font-family:monospace}
  h1{margin:0;font-size:1.02rem}
  .subtitle{font-size:0.78rem;color:var(--muted)}
  .controls{display:flex;gap:10px;align-items:center}
  .chip{background:var(--glass);border:1px solid rgba(255,255,255,0.03);padding:8px 10px;border-radius:8px;font-size:0.86rem;color:var(--muted)}
  .countdown{color:var(--red);font-weight:700}

  main{width:94%;max-width:1320px;margin:16px auto;display:grid;grid-template-columns:1fr 420px;gap:16px;}
  #cards{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.02);min-height:520px}
  .cards-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:12px}
  .card{background:linear-gradient(145deg, rgba(30,6,6,0.06), rgba(0,0,0,0.12));border-radius:var(--card-radius);padding:10px;border:1px solid rgba(255,255,255,0.02);display:flex;flex-direction:column;gap:8px;transition:transform .18s, box-shadow .18s}
  .card:hover{transform:translateY(-6px);box-shadow:0 14px 42px rgba(226,27,27,0.06)}
  .row-top{display:flex;justify-content:space-between;align-items:center}
  .gamename{font-weight:700;color:var(--red-2)}
  .tag{font-size:0.76rem;color:var(--muted);padding:6px 8px;border-radius:6px;background:var(--glass);border:1px solid rgba(255,255,255,0.02)}
  .progressbar{height:8px;background:#0f0f0f;border-radius:6px;overflow:hidden;border:1px solid rgba(255,255,255,0.02)}
  .progress-inner{height:100%;width:0%;background:linear-gradient(90deg,#00ff85,#00cc66);transition:width 1.4s cubic-bezier(.2,.8,.2,1)}
  .meta{display:flex;justify-content:space-between;align-items:center;font-size:0.82rem;color:var(--muted)}
  .spark{width:120px;height:36px}
  aside{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.06));padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.02);display:flex;flex-direction:column;gap:12px}
  .panel h3{margin:0 0 6px 0;color:var(--red-2);font-size:0.95rem}
  canvas#mainChart{width:100% !important;height:260px !important;border-radius:8px;display:block}
  button.chip{cursor:pointer}
  #movers div{padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.01);display:flex;justify-content:space-between;align-items:center}
  footer{text-align:center;color:var(--muted);padding:14px 0;font-size:0.86rem}

  @media (max-width:980px){
    main{grid-template-columns:1fr}
    .cards-grid{grid-template-columns:repeat(1,1fr)}
    aside{order:2}
  }
</style>
</head>
<body>
<header>
  <div class="title">
    <div class="logo">AI</div>
    <div>
      <h1>AI Casino Analytics</h1>
      <div class="subtitle">Stable hourly predictions · 20 of 50 games</div>
    </div>
  </div>

  <div class="controls">
    <div class="chip">Games total: <strong id="gameCount">50</strong></div>
    <div class="chip">Update: 1 hour</div>
    <div class="chip">Next update in <span class="countdown" id="countdown">--:--:--</span></div>
  </div>
</header>

<main>
  <section id="cards" aria-label="Games">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
      <div style="font-weight:700;font-size:0.98rem;color:#fff">Live Games</div>
      <div style="font-size:0.86rem;color:var(--muted)"><span id="lastUpdate">Updated: --</span></div>
    </div>

    <div class="cards-grid" id="cardsGrid"></div>
  </section>

  <aside>
    <div class="panel">
      <h3>Prediction Chart — 20 displayed games</h3>
      <canvas id="mainChart"></canvas>
    </div>

    <div class="panel">
      <h3>Top Movers</h3>
      <div id="movers"></div>
    </div>

    <div class="panel">
      <h3>Controls</h3>
      <div style="display:flex;gap:8px;flex-wrap:wrap">
        <button id="forceBtn" class="chip">Force rotate (demo)</button>
        <button id="resetBtn" class="chip">Reset storage</button>
      </div>
    </div>
  </aside>
</main>

<footer>Demo data only — stable hourly predictions. Refreshing page within the hour keeps same data.</footer>

<script>
/* -------------------------
  Stable 20-of-50 Dashboard
  Breakdown for 20: 5 >=90, 5 70-89, 5 50-69, 5 <50
  Chart: 20 bars (one per displayed game). Bars wobble (live feel) but base values are stable for the hour.
  State stored in localStorage under STORAGE_KEY; regenerated deterministically each hour.
--------------------------*/

const ALL_GAMES = [
  "Fortune Tiger","Fortune Gem","Fortune Rabbit","Fortune Ox","Wild Bounty Showdown",
  "Ganesha Gold","Pinata Wins","Fortune Snake","Golden Empire","Treasure Wild",
  "Mystic Fortune Deluxe","Dragon Hero","Starlight Princess","Lucky Neko","Sugar Rush",
  "Jewel Bonanza","Phoenix Forge","Power of Thor","Fruit Party 2","Big Bass Bonanza",
  "The Dog House","Gates of Olympus","Wild West Gold","Sweet Bonanza","Aztec Blaze",
  "Book of Golden Sands","Firebird Spirit","The Great Stick-Up","Sword of Ares","Madame Destiny Megaways",
  "Floating Dragon","Chilli Heat","Hot Fiesta","Wild Wild Bananas","Mochimon",
  "Wild Hop & Drop","Big Bass Splash","5 Lions Megaways","Tropical Tiki","Zombie Carnival",
  "Club Tropicana","Big Bass Amazon Xtreme","Monster Superlanche","Crown of Fire","Crystal Caverns",
  "Floating Treasure","Emerald King","Pirate’s Charm","Mystic Oasis","Neon Panda"
];

const STORAGE_KEY = "stable_dashboard_v2";
const DISPLAY_COUNT = 20;
const HOURLY_MS = 60 * 60 * 1000;
const TICK_MS = 1000; // wobble / UI tick

// Utilities
function getHourKey(){
  const d = new Date();
  d.setMinutes(0,0,0);
  return d.toISOString();
}
function seededRandom(seed){
  // simple seed -> returns function 0..1
  let h = 2166136261 >>> 0;
  for (let i=0;i<seed.length;i++) h = Math.imul(h ^ seed.charCodeAt(i), 16777619) >>> 0;
  return function(){
    h += 0x6D2B79F5;
    let t = Math.imul(h ^ (h >>> 15), 1 | h);
    t = t + Math.imul(t ^ (t >>> 7), 61 | t) ^ t;
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function shuffleArray(arr, rng){
  const a = arr.slice();
  for (let i=a.length-1;i>0;i--){
    const j = Math.floor(rng()* (i+1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

// load/save
function loadState(){ try{ return JSON.parse(localStorage.getItem(STORAGE_KEY)); }catch(e){ return null; } }
function saveState(s){ localStorage.setItem(STORAGE_KEY, JSON.stringify(s)); }

// generate deterministic state for the current hour if missing or outdated
function ensureState(){
  const hourKey = getHourKey();
  let state = loadState();
  if (!state || state.hourKey !== hourKey){
    // new state generation
    const rng = seededRandom(hourKey + "|pick");
    // pick 20 unique games out of 50
    const pool = ALL_GAMES.slice();
    const selected = [];
    for (let i=0;i<DISPLAY_COUNT;i++){
      const idx = Math.floor(rng()*pool.length);
      selected.push(pool.splice(idx,1)[0]);
    }
    // assign distribution: 5 >=90, 5 70-89, 5 50-69, 5 <50
    // shuffle selected first to randomize positions
    const orderRng = seededRandom(hourKey + "|order");
    const ordered = shuffleArray(selected, orderRng);
    const top90 = ordered.slice(0,5);
    const top70 = ordered.slice(5,10);
    const mid50 = ordered.slice(10,15);
    const low = ordered.slice(15,20);

    // generate stable percentages via seededRandom per game
    const hist = {}; // small history for sparkline (length 24)
    const predictions = {};
    const histLen = 24;
    for (const g of top90){
      const r = seededRandom(hourKey + "|"+g);
      // 90-99
      const val = 90 + Math.floor(r()*10);
      predictions[g] = val;
      // small history around val
      hist[g] = Array.from({length:histLen}, (_,i)=> clamp(val + Math.round((r()*10-5) + Math.sin(i/3 + r()*2)*2), 5, 99));
    }
    for (const g of top70){
      const r = seededRandom(hourKey + "|"+g);
      const val = 70 + Math.floor(r()*20); // 70-89
      predictions[g] = val;
      hist[g] = Array.from({length:histLen}, (_,i)=> clamp(val + Math.round((r()*10-5) + Math.cos(i/4 + r())*2), 5, 99));
    }
    for (const g of mid50){
      const r = seededRandom(hourKey + "|"+g);
      const val = 50 + Math.floor(r()*20); //50-69
      predictions[g] = val;
      hist[g] = Array.from({length:histLen}, (_,i)=> clamp(val + Math.round((r()*10-5) + Math.sin(i/5 + r())*2), 5, 99));
    }
    for (const g of low){
      const r = seededRandom(hourKey + "|"+g);
      const val = 5 + Math.floor(r()*45); //5-49
      predictions[g] = val;
      hist[g] = Array.from({length:histLen}, (_,i)=> clamp(val + Math.round((r()*10-5) + Math.cos(i/3 + r())*2), 5, 99));
    }

    state = {
      hourKey,
      generatedAt: Date.now(),
      displayed: ordered,
      predictions,
      hist
    };
    saveState(state);
    return state;
  }
  return state;
}

// initial state
let state = ensureState();

// UI elements
const cardsGrid = document.getElementById('cardsGrid');
const lastUpdateLabel = document.getElementById('lastUpdate');
const countdownLabel = document.getElementById('countdown');
const gameCountLabel = document.getElementById('gameCount');
const moversDiv = document.getElementById('movers');
gameCountLabel.textContent = ALL_GAMES.length;

// build cards & sparklines
function drawSparkline(canvas, series){
  if(!canvas) return;
  const ctx = canvas.getContext('2d');
  const DPR = window.devicePixelRatio || 1;
  const w = canvas.clientWidth * DPR;
  const h = canvas.clientHeight * DPR;
  canvas.width = w; canvas.height = h;
  ctx.clearRect(0,0,w,h);
  if(!series || series.length===0) return;
  const minV = Math.min(...series); const maxV = Math.max(...series);
  // background
  ctx.fillStyle = 'rgba(255,255,255,0.02)';
  ctx.fillRect(0,0,w,h);
  // stroke
  const grad = ctx.createLinearGradient(0,0,w,0);
  grad.addColorStop(0,'rgba(0,255,133,0.95)');
  grad.addColorStop(1,'rgba(226,27,27,0.95)');
  ctx.strokeStyle = grad; ctx.lineWidth = 1.5 * DPR; ctx.beginPath();
  for(let i=0;i<series.length;i++){
    const x = (i/(series.length-1))*(w-6*DPR)+3*DPR;
    const y = h - ((series[i]-minV)/(maxV-minV||1))*(h-6*DPR)-3*DPR;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();
  // draw last dot
  const lx = ( (series.length-1)/(series.length-1) )*(w-6*DPR)+3*DPR;
  const ly = h - ((series[series.length-1]-minV)/(maxV-minV||1))*(h-6*DPR)-3*DPR;
  ctx.beginPath();
  ctx.arc(lx,ly,3*DPR,0,Math.PI*2); ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.fill();
}

// render card DOMs
function renderCards(){
  cardsGrid.innerHTML = '';
  const arr = state.displayed.map(name => ({
    name,
    percent: state.predictions[name],
    hist: state.hist[name]
  }));
  // sort by percent desc so UI shows top first
  arr.sort((a,b)=>b.percent - a.percent);
  for(const item of arr){
    const card = document.createElement('div');
    card.className = 'card';
    const colorClass = item.percent > 50 ? 'green' : 'red';
    // progress bar color: if percent >50 use green gradient, else red gradient (we set inline CSS)
    const progressColor = item.percent > 50 ? 'linear-gradient(90deg,#00ff85,#00cc66)' : 'linear-gradient(90deg,#ff5b5b,#e21b1b)';
    card.innerHTML = `
      <div class="row-top">
        <div>
          <div class="gamename">${item.name}</div>
          <div class="tag">${timeRangeFor(item.name)}</div>
        </div>
        <div style="text-align:right">
          <div style="font-weight:800;color:${item.percent>50? '#aef7d0':'#ffbebe'};font-size:1.02rem">${item.percent}%</div>
          <div style="font-size:0.78rem;color:var(--muted)">${trendFor(item.hist) >= 0 ? '▲' : '▼'} ${Math.abs(Math.round(trendFor(item.hist)))} </div>
        </div>
      </div>
      <div>
        <div class="progressbar" aria-hidden="true"><div class="progress-inner" style="width:${item.percent}%; background:${progressColor}"></div></div>
      </div>
      <div class="meta">
        <div>Confidence: <strong style="color:var(--red)">${computeConfidence(item.hist)}%</strong></div>
        <div><canvas class="spark" data-name="${item.name}"></canvas></div>
      </div>
    `;
    cardsGrid.appendChild(card);
    // draw sparkline after DOM insert
    const canvas = card.querySelector('canvas.spark');
    drawSparkline(canvas, item.hist);
  }
  lastUpdateLabel.textContent = "Updated: " + new Date(state.generatedAt).toLocaleString();
}

// small helpers for timeRange/trend/confidence
function timeRangeFor(name){
  // deterministic pick per game & hour
  const ranges = ["12AM-2AM","2AM-4AM","4AM-6AM","6AM-8AM","8AM-10AM","10AM-12PM","12PM-2PM","2PM-4PM","4PM-6PM","6PM-8PM","8PM-10PM","10PM-12AM"];
  const rng = seededRandom(state.hourKey + "|tr|" + name);
  return ranges[Math.floor(rng()*ranges.length)];
}
function trendFor(series){
  if(!series || series.length<2) return 0;
  const last6 = series.slice(-6);
  let s=0;
  for(let i=1;i<last6.length;i++) s += last6[i]-last6[i-1];
  return s / Math.max(1,last6.length-1);
}
function computeConfidence(series){
  if(!series || series.length<2) return 80;
  const mean = series.reduce((a,b)=>a+b,0)/series.length;
  const variance = series.reduce((a,b)=>a + Math.pow(b-mean,2),0)/Math.max(1,series.length-1);
  const vol = Math.sqrt(Math.max(0,variance));
  let conf = Math.round(Math.max(30, 100 - vol*8));
  return conf;
}

// Chart: 20 bars
const chartCtx = document.getElementById('mainChart').getContext('2d');
function buildChart(){
  const labels = state.displayed.slice();
  const baseValues = labels.map(n => state.predictions[n]);
  const colors = baseValues.map(v => v > 50 ? 'rgba(0,255,133,0.95)' : 'rgba(226,27,27,0.95)');
  return new Chart(chartCtx, {
    type: 'bar',
    data: {
      labels,
      datasets: [{
        label:'Prediction %',
        data: baseValues,
        backgroundColor: colors,
        borderRadius: 6,
        barThickness: 18
      }]
    },
    options: {
      animation: { duration: 700 },
      plugins: { legend: { display: false } },
      scales: {
        x: { ticks:{color:'#ddd'}, grid:{display:false} },
        y: { min:0, max:100, ticks:{color:'#ddd'}, grid:{color:'rgba(255,255,255,0.03)'} }
      }
    }
  });
}

let chart = buildChart();

// Live wobble: small per-second update that nudges chart values visually but does not change base state
function wobbleChartTick(){
  const labels = state.displayed.slice();
  const base = labels.map(n => state.predictions[n]);
  const hourKey = state.hourKey;
  const rng = seededRandom(hourKey + "|wobble|" + Math.round(Date.now()/5000)); // changes every 5s deterministically within hour
  // for each bar, compute a tiny offset -2..+2
  const jittered = base.map((v,i) => clamp(Math.round(v + (rng()*4 - 2)), 0, 100));
  chart.data.datasets[0].data = jittered;
  // update colors in case jitter crosses 50 threshold visually (keeps green/red behavior tied to base value, though)
  chart.data.datasets[0].backgroundColor = base.map(v => v > 50 ? 'rgba(0,255,133,0.95)' : 'rgba(226,27,27,0.95)');
  chart.update('none');
}

// Movers: top absolute trend magnitude
function updateMovers(){
  const arr = state.displayed.map(n => ({name:n, trend: Math.abs(trendFor(state.hist[n])), pct: state.predictions[n]}));
  arr.sort((a,b)=>b.trend - a.trend);
  moversDiv.innerHTML = '';
  for(let i=0;i<5;i++){
    const m = arr[i];
    const div = document.createElement('div');
    div.innerHTML = `<div style="font-weight:700;color:${m.pct>50? '#aef7d0':'#ffbebe'}">${m.name}</div><div style="color:var(--muted)">${Math.round(m.trend)} | ${m.pct}%</div>`;
    moversDiv.appendChild(div);
  }
}

// UI refresh
function refreshUI(){
  renderCards();
  updateMovers();
  // chart rebuild? update labels & base dataset
  chart.data.labels = state.displayed.slice();
  chart.data.datasets[0].data = state.displayed.map(n => state.predictions[n]);
  chart.data.datasets[0].backgroundColor = state.displayed.map(n => state.predictions[n] > 50 ? 'rgba(0,255,133,0.95)' : 'rgba(226,27,27,0.95)');
  chart.update();
  document.getElementById('lastUpdate').textContent = "Updated: " + new Date(state.generatedAt).toLocaleString();
}

// countdown to next hour
function updateCountdownLabel(){
  const now = new Date();
  const next = new Date(now); next.setMinutes(60,0,0);
  const diff = Math.max(0, next - now);
  const hh = String(Math.floor(diff/3600000)).padStart(2,'0');
  const mm = String(Math.floor((diff%3600000)/60000)).padStart(2,'0');
  const ss = String(Math.floor((diff%60000)/1000)).padStart(2,'0');
  document.getElementById('countdown').textContent = `${hh}:${mm}:${ss}`;
}

// periodic tick for wobble + countdown + hour rollover check
setInterval(()=>{
  // countdown update
  updateCountdownLabel();
  // chart wobble tick
  wobbleChartTick();
  // every 15s check if hour changed (so new state will be generated close to actual hour)
  // but we also do a separate interval which checks hourly; this is a quick check
  const currentHour = getHourKey();
  if (currentHour !== state.hourKey){
    // regenerate state for new hour
    state = ensureState();
    // rebuild chart completely to reset dataset sizes etc.
    chart.destroy();
    chart = buildChart();
    refreshUI();
  }
}, TICK_MS);

// button handlers
document.getElementById('forceBtn').addEventListener('click', ()=>{
  // For demo: force rotation by clearing saved state and re-ensuring
  if (!confirm('Force rotate displayed 20 games now? This will re-generate this hour\'s picks.')) return;
  localStorage.removeItem(STORAGE_KEY);
  state = ensureState();
  chart.destroy();
  chart = buildChart();
  refreshUI();
});

document.getElementById('resetBtn').addEventListener('click', ()=>{
  if (!confirm('Reset all saved dashboard data?')) return;
  localStorage.removeItem(STORAGE_KEY);
  state = ensureState();
  chart.destroy();
  chart = buildChart();
  refreshUI();
});

// initial render
refreshUI();
updateCountdownLabel();

</script>
</body>
</html>
